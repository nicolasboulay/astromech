<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SIMULATEUR: algoPICs.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="files.html">File&nbsp;List</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>algoPICs.cpp</h1><pre class="fragment"><div>00001 <span class="preprocessor">#include "module.h"</span>
00002 <span class="preprocessor">#include "algo.h"</span>
00003 <span class="preprocessor">#include "algoPICs.h"</span>
00004 <span class="preprocessor">#include "systeme.h"</span>
00005 <span class="preprocessor">#include "trace.h"</span>
00006 <span class="preprocessor">#include "tinyxml.h"</span>
00007 <span class="preprocessor">#include "comSeriePC_PIC.h"</span>
00008 <span class="preprocessor">#include "senseur.h"</span>
00009 <span class="preprocessor">#include "codeuse.h"</span>
00010 <span class="preprocessor">#include "effecteur.h"</span>
00011 <span class="preprocessor">#include "moteur.h"</span>
00012 <span class="preprocessor">#include "geom2D.h"</span>
00013 <span class="preprocessor">#include &lt;math.h&gt;</span>
00014 <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00015 
00016 AlgoPIC::AlgoPIC(Systeme *s,Trace * t):Algo(s,t)
00017 {
00018   trace = t;
00019   src = <span class="stringliteral">"algoPICs.cpp"</span>;
00020   cl = <span class="stringliteral">"AlgoPIC"</span>;
00021   message = <span class="stringliteral">"debut"</span>;
00022   trace-&gt;print(src,cl,<span class="stringliteral">"AlgoPIC"</span>,message);
00023   numeroWPenCours = 0;
00024   vitesseConsigneCG_m_par_s = 0;
00025   numeroSequenceWP = -1;
00026   positionAttVit = <span class="keyword">new</span> WayPoint(0,0,0,0);
00027 
00028   message = <span class="stringliteral">"fin"</span>;
00029   trace-&gt;print(src,cl,<span class="stringliteral">"AlgoPIC"</span>,message);
00030 }
00031 
00032 AlgoPIC::~AlgoPIC(<span class="keywordtype">void</span>)
00033 {
00034   message = <span class="stringliteral">"debut"</span>;
00035   trace-&gt;print(src,cl,<span class="stringliteral">"~AlgoPIC"</span>,message);
00036   
00037   <span class="keyword">delete</span> positionAttVit;
00038   
00039   message = <span class="stringliteral">"fin"</span>;
00040   trace-&gt;print(src,cl,<span class="stringliteral">"~AlgoPIC"</span>,message);
00041 }
00042 
00043 <span class="keywordtype">void</span> AlgoPIC::execute(<span class="keywordtype">int</span> tempsCourant_ms)
00044 {
00045   message = <span class="stringliteral">"debut"</span>;
00046   trace-&gt;print(src,cl,<span class="stringliteral">"execute"</span>,message);
00047   log &lt;&lt;  tempsCourant_ms&lt;&lt;<span class="stringliteral">"\t"</span>;
00048   <span class="keywordflow">if</span> (comSerie-&gt;tramePC_PIC_recue())
00049   {
00050     TramePC_PIC * trameRecue;
00051     trameRecue = comSerie-&gt;getTramePC_PIC();
00052     cout &lt;&lt; <span class="stringliteral">"trameRecue "</span>&lt;&lt;trameRecue&lt;&lt;endl;
00053     cout &lt;&lt; <span class="stringliteral">"listeWP "</span>&lt;&lt;&amp;(trameRecue-&gt;tabWayPoint)&lt;&lt;endl;
00054     <span class="comment">//lecture trame et sauvegarde des données en local</span>
00055     <span class="keywordflow">if</span> (this-&gt;numeroSequenceWP!=trameRecue-&gt;numeroSequenceWP)
00056     {
00057       this-&gt;numeroSequenceWP = trameRecue-&gt;numeroSequenceWP;
00058       <span class="comment">//on efface la liste des wp precedente</span>
00059       vectorWayPoint::iterator it;
00060       cout &lt;&lt; <span class="stringliteral">"taille listeWPC "</span>&lt;&lt;listeWPCourante.size()&lt;&lt;endl;;
00061       <span class="keywordflow">for</span> (it = listeWPCourante.begin();it!=listeWPCourante.end();++it)
00062       {
00063         <span class="keyword">delete</span>(*it);
00064       }
00065       listeWPCourante.clear();
00066       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> indWP = 0;indWP &lt; trameRecue-&gt;tabWayPoint.size();indWP++)
00067       {
00068         <span class="comment">//recopie des wp dans la trame</span>
00069         WayPoint * wp = <span class="keyword">new</span> WayPoint(trameRecue-&gt;tabWayPoint[indWP]-&gt;pt-&gt;x,
00070                                      trameRecue-&gt;tabWayPoint[indWP]-&gt;pt-&gt;y,
00071                                      trameRecue-&gt;tabWayPoint[indWP]-&gt;attitude_rad,
00072                                      trameRecue-&gt;tabWayPoint[indWP]-&gt;vitesse_m_par_s);
00073         listeWPCourante.push_back(wp);
00074       }
00075     }  
00076     <span class="keyword">delete</span> trameRecue;
00077     <span class="comment">//traitements</span>
00078     
00079     <span class="comment">//création d'une trame pour le PC</span>
00080     TramePIC_PC * trameEnvoyee = <span class="keyword">new</span> TramePIC_PC();
00081     comSerie-&gt;sendToPC(trameEnvoyee);
00082   }
00083   <span class="comment">//code temporaire</span>
00084  <span class="comment">/* vectorWayPoint listeWP;</span>
00085 <span class="comment">  WayPoint * wp1 = new WayPoint(1,1,0,0.3);//coord (1,1) vit 0.3m/s</span>
00086 <span class="comment">  WayPoint * wp2 = new WayPoint(2,2,1.57,0.5);//coord (2,2) vit 1m/s</span>
00087 <span class="comment">  WayPoint * wp3 = new WayPoint(3,2,1.57,0.5);//coord (3,2) vit 1m/s</span>
00088 <span class="comment">  WayPoint * wp4 = new WayPoint(3,0,4.71,0);//coord (3,0) vit 1m/s</span>
00089 <span class="comment">  listeWP.push_back(wp1);</span>
00090 <span class="comment">  listeWP.push_back(wp2);</span>
00091 <span class="comment">  listeWP.push_back(wp3);</span>
00092 <span class="comment">  listeWP.push_back(wp4);*/</span>
00093   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> indWP = 0;indWP &lt; listeWPCourante.size();indWP++)
00094       {
00095   cout &lt;&lt; listeWPCourante[indWP]-&gt;pt-&gt;x&lt;&lt;endl;
00096   cout &lt;&lt; listeWPCourante[indWP]-&gt;pt-&gt;y&lt;&lt;endl;
00097   cout &lt;&lt; listeWPCourante[indWP]-&gt;attitude_rad&lt;&lt;endl;
00098   cout &lt;&lt; listeWPCourante[indWP]-&gt;vitesse_m_par_s&lt;&lt;endl;}
00099   <span class="comment">//lecture des codeuses</span>
00100   <span class="keywordtype">double</span> codeuseMoteurDroit = codeuseDroite-&gt;getNbImpulsions();
00101   <span class="keywordtype">double</span> codeuseMoteurGauche = codeuseGauche-&gt;getNbImpulsions();
00102   
00103   <span class="comment">//mise à jour navigation</span>
00104   miseAjourNavigation(codeuseMoteurDroit,codeuseMoteurGauche);
00105   
00106   <span class="comment">//incrémentation du waypoint si le courant est atteint</span>
00107   miseAjourWaypoint(listeWPCourante);
00108   
00109   <span class="comment">//boucle de guidage</span>
00110   <span class="keywordtype">double</span> consigneVitesseMoteurDroit_rad_s = 0;
00111   <span class="keywordtype">double</span> consigneVitesseMoteurGauche_rad_s = 0;
00112   boucleGuidage(listeWPCourante,
00113                 consigneVitesseMoteurDroit_rad_s, 
00114                 consigneVitesseMoteurGauche_rad_s);
00115   
00116   <span class="comment">//commande des moteurs</span>
00117   moteurDroit-&gt;setConsigneVitesse(consigneVitesseMoteurDroit_rad_s);
00118   moteurGauche-&gt;setConsigneVitesse(consigneVitesseMoteurGauche_rad_s);
00119   
00120 
00121   
00122   message = <span class="stringliteral">"fin"</span>;
00123   trace-&gt;print(src,cl,<span class="stringliteral">"execute"</span>,message);
00124 }
00125 
00126 <span class="keywordtype">void</span> AlgoPIC::chargerXML(TiXmlElement* pModuleXML)
00127 {
00128   message = <span class="stringliteral">"debut"</span>;
00129   trace-&gt;print(src,cl,<span class="stringliteral">"chargerXML"</span>,message);
00130   Algo::chargerXML(pModuleXML);
00131 
00132   TiXmlElement* pElt;
00133   TiXmlHandle handleModule(0);
00134   handleModule = TiXmlHandle(pModuleXML);
00135   
00136   pElt = handleModule.FirstChild(<span class="stringliteral">"nbPointsParTourMoteur"</span>).Element();
00137   istringstream iss( pElt-&gt;GetText() );
00138   iss &gt;&gt; nbPointsParTourMoteur;
00139   message = <span class="stringliteral">"nbPointsParTourMoteur : "</span> + iss.str();
00140   trace-&gt;print(src,cl,<span class="stringliteral">"chargerXML"</span>,message);
00141   
00142   pElt = handleModule.FirstChild(<span class="stringliteral">"rapportReduction"</span>).Element();
00143   istringstream iss2( pElt-&gt;GetText() );
00144   iss2 &gt;&gt; rapportReduction;
00145   message = <span class="stringliteral">"rapportReduction : "</span> + iss2.str();
00146   trace-&gt;print(src,cl,<span class="stringliteral">"chargerXML"</span>,message);
00147 
00148   pElt = handleModule.FirstChild(<span class="stringliteral">"rayonRoues_m"</span>).Element();
00149   istringstream iss3( pElt-&gt;GetText() );
00150   iss3 &gt;&gt; rayonRoues_m;
00151   message = <span class="stringliteral">"rayonRoues_m : "</span> + iss3.str();
00152   trace-&gt;print(src,cl,<span class="stringliteral">"chargerXML"</span>,message);
00153   
00154   pElt = handleModule.FirstChild(<span class="stringliteral">"ecartEntreRoues_m"</span>).Element();
00155   istringstream iss4( pElt-&gt;GetText() );
00156   iss4 &gt;&gt; ecartEntreRoues_m;
00157   message = <span class="stringliteral">"ecartEntreRoues_m : "</span> + iss4.str();
00158   trace-&gt;print(src,cl,<span class="stringliteral">"chargerXML"</span>,message);
00159 
00160   pElt = handleModule.FirstChild(<span class="stringliteral">"accelMax_m_par_s2"</span>).Element();
00161   istringstream iss5( pElt-&gt;GetText() );
00162   iss5 &gt;&gt; accelMax_m_par_s2;
00163   message = <span class="stringliteral">"accelMax_m_par_s2 : "</span> + iss5.str();
00164   trace-&gt;print(src,cl,<span class="stringliteral">"chargerXML"</span>,message);
00165   
00166   pElt = handleModule.FirstChild(<span class="stringliteral">"decelMax_m_par_s2"</span>).Element();
00167   istringstream iss6( pElt-&gt;GetText() );
00168   iss6 &gt;&gt; decelMax_m_par_s2;
00169   message = <span class="stringliteral">"decelMax_m_par_s2 : "</span> + iss6.str();
00170   trace-&gt;print(src,cl,<span class="stringliteral">"chargerXML"</span>,message);
00171   
00172   pElt = handleModule.FirstChild(<span class="stringliteral">"gainCorrectionAngulaire"</span>).Element();
00173   istringstream iss7( pElt-&gt;GetText() );
00174   iss7 &gt;&gt; gainCorrectionAngulaire;
00175   message = <span class="stringliteral">"gainCorrectionAngulaire : "</span> + iss7.str();
00176   trace-&gt;print(src,cl,<span class="stringliteral">"chargerXML"</span>,message);
00177   
00178   pElt = handleModule.FirstChild(<span class="stringliteral">"tempsMiseEnDecel_s"</span>).Element();
00179   istringstream iss8( pElt-&gt;GetText() );
00180   iss8 &gt;&gt; tempsMiseEnDecel_s;
00181   message = <span class="stringliteral">"tempsMiseEnDecel_s : "</span> + iss8.str();
00182   trace-&gt;print(src,cl,<span class="stringliteral">"chargerXML"</span>,message);
00183 
00184   log &lt;&lt;<span class="stringliteral">"t(s)"</span>&lt;&lt;<span class="stringliteral">"\t"</span>&lt;&lt;<span class="stringliteral">"xR(m)"</span>&lt;&lt;<span class="stringliteral">"\t"</span>&lt;&lt;<span class="stringliteral">"yR(m)"</span>&lt;&lt;<span class="stringliteral">"\t"</span>&lt;&lt;<span class="stringliteral">"vR(m/s)"</span>&lt;&lt;<span class="stringliteral">"\t"</span>&lt;&lt;<span class="stringliteral">"N° WP"</span>&lt;&lt;<span class="stringliteral">"\t"</span>&lt;&lt;<span class="stringliteral">"dist WP (m)"</span>&lt;&lt;<span class="stringliteral">"\t"</span>
00185       &lt;&lt;<span class="stringliteral">"xCentreCercle(m)"</span>&lt;&lt;<span class="stringliteral">"\t"</span>&lt;&lt;<span class="stringliteral">"yCentreCercle(m)"</span>&lt;&lt;<span class="stringliteral">"\t"</span>&lt;&lt;<span class="stringliteral">"directionWP(rad)"</span>&lt;&lt;<span class="stringliteral">"\t"</span>
00186       &lt;&lt;<span class="stringliteral">"xRobot/WP(m)"</span>&lt;&lt;<span class="stringliteral">"\t"</span>&lt;&lt;<span class="stringliteral">"yRobot/WP(m)"</span>&lt;&lt;<span class="stringliteral">"\t"</span>&lt;&lt;<span class="stringliteral">"Rayon(m)"</span>&lt;&lt;<span class="stringliteral">"\t"</span>&lt;&lt;<span class="stringliteral">"capRobot(rad)"</span>&lt;&lt;<span class="stringliteral">"\t"</span>
00187       &lt;&lt;<span class="stringliteral">"capCercleIdeal(rad)"</span>&lt;&lt;<span class="stringliteral">"\t"</span>&lt;&lt;<span class="stringliteral">"ecartAngulaire_rad(rad)"</span>&lt;&lt;<span class="stringliteral">"\t"</span>
00188       &lt;&lt;<span class="stringliteral">"consV_MDroit(rad/s)"</span>&lt;&lt;<span class="stringliteral">"\t"</span>&lt;&lt;<span class="stringliteral">"consV_MGauche(rad/s)"</span>&lt;&lt;<span class="stringliteral">"\t"</span>
00189       &lt;&lt;<span class="stringliteral">"vConsCGrad/s"</span>&lt;&lt;<span class="stringliteral">"\t"</span>&lt;&lt;<span class="stringliteral">"distCurvWP(m)"</span>&lt;&lt;<span class="stringliteral">"\t"</span>&lt;&lt;<span class="stringliteral">"distDecel(m)"</span>&lt;&lt;endl;
00190 
00191   message = <span class="stringliteral">"fin"</span>;
00192   trace-&gt;print(src,cl,<span class="stringliteral">"chargerXML"</span>,message);
00193 }
00194 
00195 <span class="keywordtype">void</span> AlgoPIC::connectModules(<span class="keywordtype">void</span>)
00196 {
00197   message = <span class="stringliteral">"debut"</span>;
00198   trace-&gt;print(src,cl,<span class="stringliteral">"connectModules"</span>,message);
00199   
00200   string nomModule;
00201   vectorString::iterator it;
00202   it = tabRelation.begin();
00203   <span class="keywordflow">if</span> (tabRelation.size() == 5)
00204   {
00205     nomModule = *it;
00206     comSerie = (ComSeriePC_PIC *)systPere-&gt;getPtrModule(nomModule);
00207     message = <span class="stringliteral">"connection à :"</span> + nomModule;
00208     trace-&gt;print(src,cl,<span class="stringliteral">"connectModules"</span>,message);
00209     
00210     it++;
00211     
00212     nomModule = *it;
00213     codeuseDroite = (Codeuse *)systPere-&gt;getPtrModule(nomModule);
00214     message = <span class="stringliteral">"connection à :"</span> + nomModule;
00215     trace-&gt;print(src,cl,<span class="stringliteral">"connectModules"</span>,message);
00216    
00217     it++;
00218          
00219     nomModule = *it;
00220     codeuseGauche = (Codeuse *)systPere-&gt;getPtrModule(nomModule);
00221     message = <span class="stringliteral">"connection à :"</span> + nomModule;
00222     trace-&gt;print(src,cl,<span class="stringliteral">"connectModules"</span>,message);
00223     
00224     it++;
00225          
00226     nomModule = *it;
00227     moteurDroit = (Moteur *)systPere-&gt;getPtrModule(nomModule);
00228     message = <span class="stringliteral">"connection à :"</span> + nomModule;
00229     trace-&gt;print(src,cl,<span class="stringliteral">"connectModules"</span>,message);
00230     
00231     it++;
00232          
00233     nomModule = *it;
00234     moteurGauche = (Moteur *)systPere-&gt;getPtrModule(nomModule);
00235     message = <span class="stringliteral">"connection à :"</span> + nomModule;
00236     trace-&gt;print(src,cl,<span class="stringliteral">"connectModules"</span>,message);
00237   }
00238   
00239   message = <span class="stringliteral">"fin"</span>;
00240   trace-&gt;print(src,cl,<span class="stringliteral">"connectModules"</span>,message);
00241 }
00242 
00243 <span class="keywordtype">void</span> AlgoPIC::miseAjourNavigation(<span class="keyword">const</span> <span class="keywordtype">double</span> &amp; impCodeuseMoteurDroit,
00244                                   <span class="keyword">const</span> <span class="keywordtype">double</span> &amp; impCodeuseMoteurGauche)
00245 {
00246   <span class="comment">//(2Pi*R)/(500*36) * NbImp = distance</span>
00247   <span class="keywordtype">double</span> facteurConversion = 2*M_PI*rayonRoues_m/(nbPointsParTourMoteur*rapportReduction);<span class="comment">//0.0000175;</span>
00248   <span class="keywordtype">double</span> deplacementRoueDroite = facteurConversion*impCodeuseMoteurDroit;
00249   <span class="keywordtype">double</span> deplacementRoueGauche = facteurConversion*impCodeuseMoteurGauche;
00250 
00251   <span class="keywordtype">double</span> deltaAvance_m = (deplacementRoueDroite + deplacementRoueGauche)/2;
00252   <span class="keywordtype">double</span> new_pos_x_m = positionAttVit-&gt;pt-&gt;x + deltaAvance_m * sin(positionAttVit-&gt;attitude_rad);
00253   <span class="keywordtype">double</span> new_pos_y_m = positionAttVit-&gt;pt-&gt;y + deltaAvance_m * cos(positionAttVit-&gt;attitude_rad);
00254   <span class="keywordtype">double</span> new_att_rad = positionAttVit-&gt;attitude_rad + atan((deplacementRoueGauche - deplacementRoueDroite)/ecartEntreRoues_m);
00255   normalise0_2PI(new_att_rad);
00256   <span class="comment">//mise à jour position</span>
00257   positionAttVit-&gt;pt-&gt;x = new_pos_x_m;
00258   positionAttVit-&gt;pt-&gt;y = new_pos_y_m;
00259   positionAttVit-&gt;attitude_rad = new_att_rad;
00260   positionAttVit-&gt;vitesse_m_par_s = (deltaAvance_m/pasTemps_ms)*1000; <span class="comment">//100Hz</span>
00261   log &lt;&lt; new_pos_x_m &lt;&lt;<span class="stringliteral">"\t"</span>&lt;&lt; new_pos_y_m &lt;&lt;<span class="stringliteral">"\t"</span>&lt;&lt;positionAttVit-&gt;vitesse_m_par_s &lt;&lt;<span class="stringliteral">"\t"</span>;
00262 }
00263 
00264 <span class="keywordtype">void</span> AlgoPIC::boucleGuidage(vectorWayPoint listeWP,
00265                 <span class="keywordtype">double</span> &amp; consigneVitesseMoteurDroit_rad_s, 
00266                 <span class="keywordtype">double</span> &amp; consigneVitesseMoteurGauche_rad_s)
00267 {
00268   WayPoint * wpEnCours;
00269   <span class="keywordflow">if</span> (numeroWPenCours &lt; listeWP.size())
00270   {
00271     wpEnCours = listeWP[numeroWPenCours];
00272     Point2D * centreDuCercle = <span class="keyword">new</span> Point2D(0,0);
00273     <span class="comment">//calcul de la position courante dans le repere du WP en cours</span>
00274     Point2D * ptCourant = <span class="keyword">new</span> Point2D(positionAttVit-&gt;pt);
00275     ptCourant-&gt;calculePointDansNouveauRepere(wpEnCours-&gt;pt,wpEnCours-&gt;attitude_rad);
00276     
00277     <span class="comment">//calcul du centre du cercle ideal pour joindre le waypoint dans le repere du waypoint</span>
00278     <span class="keywordtype">double</span> xRobot,yRobot;
00279     xRobot = ptCourant-&gt;x;
00280     yRobot = ptCourant-&gt;y;
00281     <span class="keyword">delete</span> ptCourant;
00282     <span class="keywordtype">double</span> capCercleIdeal;
00283     <span class="keywordtype">double</span> xCentreCercle;
00284     <span class="keywordflow">if</span> (xRobot != 0) <span class="comment">//cas ou le robot n'est pas pile dans l'axe du waypoint</span>
00285     {
00286       xCentreCercle = (xRobot*xRobot+yRobot*yRobot)/(2*xRobot);
00287       <span class="comment">//Point2D * centreDuCercle = new Point2D(xCentreCercle,0);</span>
00288       centreDuCercle-&gt;x = xCentreCercle;
00289       centreDuCercle-&gt;y = 0;
00290         
00291       <span class="comment">//calcul du centre du cercle dans le repere terrain</span>
00292       centreDuCercle-&gt;calculePointDansRepereTerrain(wpEnCours-&gt;pt,wpEnCours-&gt;attitude_rad);
00293       log &lt;&lt; centreDuCercle-&gt;x &lt;&lt;<span class="stringliteral">"\t"</span>&lt;&lt;centreDuCercle-&gt;y&lt;&lt;<span class="stringliteral">"\t"</span>;
00294       log &lt;&lt;  wpEnCours-&gt;attitude_rad&lt;&lt;<span class="stringliteral">"\t"</span>&lt;&lt;xRobot &lt;&lt;<span class="stringliteral">"\t"</span>&lt;&lt; yRobot &lt;&lt;<span class="stringliteral">"\t"</span>&lt;&lt; xCentreCercle&lt;&lt;<span class="stringliteral">"\t"</span>;
00295 
00296       <span class="comment">//calcul du cap pt Robot / centre Cercle</span>
00297       <span class="keywordtype">double</span> capRobotCentre = positionAttVit-&gt;pt-&gt;calculeCap_rad(centreDuCercle);
00298       
00299       <span class="keywordflow">if</span> (xRobot &gt; 0)
00300       {
00301         capCercleIdeal = capRobotCentre + 3*M_PI/2;
00302       }
00303       <span class="keywordflow">else</span>
00304       {
00305         capCercleIdeal = capRobotCentre + M_PI/2;
00306       }
00307     }
00308     <span class="keywordflow">else</span>
00309     {
00310       <span class="comment">//ligne droite pour rejoindre le wp</span>
00311       capCercleIdeal = wpEnCours-&gt;attitude_rad;
00312     }
00313     normalise0_2PI(capCercleIdeal);
00314     <span class="keywordtype">double</span> ecartAngulaire_rad = capCercleIdeal - positionAttVit-&gt;attitude_rad;
00315     normaliseMPI_PPI(ecartAngulaire_rad);
00316     
00317     <span class="comment">//calcul de la vitesse du centre de gravité du robot</span>
00318     <span class="keywordtype">double</span> distanceCurviligneJusqueWP = 0;
00319     <span class="keywordtype">double</span> distanceDeceleration = 0;
00320     <span class="keywordflow">if</span> (vitesseConsigneCG_m_par_s &lt;= wpEnCours-&gt;vitesse_m_par_s)
00321     {
00322       <span class="comment">//il faut accélérer</span>
00323       cout &lt;&lt; <span class="stringliteral">"vc"</span>&lt;&lt;positionAttVit-&gt;vitesse_m_par_s&lt;&lt;endl;
00324       cout &lt;&lt; <span class="stringliteral">"vobj"</span>&lt;&lt;wpEnCours-&gt;vitesse_m_par_s&lt;&lt;endl;
00325       
00326       <span class="keywordtype">double</span> nouvelleVitesse_m_par_s = vitesseConsigneCG_m_par_s + (pasTemps_ms*accelMax_m_par_s2)/1000;
00327       <span class="keywordflow">if</span> (nouvelleVitesse_m_par_s &lt; wpEnCours-&gt;vitesse_m_par_s)
00328       {
00329         vitesseConsigneCG_m_par_s = nouvelleVitesse_m_par_s;
00330         cout &lt;&lt; <span class="stringliteral">"vcg"</span>&lt;&lt;vitesseConsigneCG_m_par_s&lt;&lt;endl;
00331       }
00332     }
00333     <span class="keywordflow">else</span>
00334     {
00335       <span class="comment">//il faut décelerer le plus tard possible</span>
00336       <span class="comment">//calcul de la distance curviligne au WP courant</span>
00337       <span class="keywordtype">double</span> capCentreCercle_Robot = centreDuCercle-&gt;calculeCap_rad(positionAttVit-&gt;pt);
00338       <span class="keywordtype">double</span> capCentreCercle_WP = centreDuCercle-&gt;calculeCap_rad(wpEnCours-&gt;pt);
00339       normaliseMPI_PPI(capCentreCercle_Robot);
00340       normaliseMPI_PPI(capCentreCercle_WP);
00341       <span class="keywordtype">double</span> ecartAngulairePourRejoindreWP = capCentreCercle_WP - capCentreCercle_Robot;
00342       normalise0_2PI(ecartAngulairePourRejoindreWP);
00343       distanceCurviligneJusqueWP = ecartAngulairePourRejoindreWP * xCentreCercle;
00344       cout &lt;&lt;<span class="stringliteral">"capCentreCercle_Robot"</span>&lt;&lt; capCentreCercle_Robot &lt;&lt;endl;
00345        cout &lt;&lt;<span class="stringliteral">"capCentreCercle_WP"</span>&lt;&lt; capCentreCercle_WP &lt;&lt;endl;
00346        cout &lt;&lt;<span class="stringliteral">"centreDuCercleX"</span>&lt;&lt;centreDuCercle-&gt;x&lt;&lt;endl;
00347        cout &lt;&lt;<span class="stringliteral">"centreDuCercleY"</span>&lt;&lt;centreDuCercle-&gt;y&lt;&lt;endl;
00348        cout &lt;&lt;<span class="stringliteral">"wpX"</span>&lt;&lt;wpEnCours-&gt;pt-&gt;x&lt;&lt;endl;
00349        cout &lt;&lt;<span class="stringliteral">"wpY"</span>&lt;&lt;wpEnCours-&gt;pt-&gt;y&lt;&lt;endl;
00350       cout &lt;&lt;<span class="stringliteral">"ecartAngulairePourRejoindreWP"</span>&lt;&lt; ecartAngulairePourRejoindreWP &lt;&lt;endl;
00351       
00352       <span class="comment">//calcul de la distance de décélération</span>
00353       <span class="keywordtype">double</span> deltaVitesseCourant = wpEnCours-&gt;vitesse_m_par_s - vitesseConsigneCG_m_par_s;
00354       distanceDeceleration = (deltaVitesseCourant*deltaVitesseCourant)/(2*decelMax_m_par_s2)
00355                              +vitesseConsigneCG_m_par_s*tempsMiseEnDecel_s;<span class="comment">//terme correctif pour tenir compte de la différence entre</span>
00356                              <span class="comment">//vitesse de consigne et vitesse réalisée</span>
00357       
00358       <span class="comment">//faut il décelerer?</span>
00359       <span class="keywordflow">if</span> (distanceCurviligneJusqueWP &lt;= distanceDeceleration)
00360       {
00361         vitesseConsigneCG_m_par_s = vitesseConsigneCG_m_par_s - (pasTemps_ms*decelMax_m_par_s2)/1000;
00362       }
00363     }
00364     
00365     <span class="keywordtype">double</span> deltaV; 
00366     <span class="keywordtype">double</span> vitesseConsigneCG_rad_par_s = vitesseConsigneCG_m_par_s*rapportReduction/rayonRoues_m;
00367     <span class="keywordflow">if</span> (ecartAngulaire_rad&gt;0)
00368     {
00369       deltaV = vitesseConsigneCG_rad_par_s*(gainCorrectionAngulaire*ecartAngulaire_rad -1)/(gainCorrectionAngulaire*ecartAngulaire_rad + 1);
00370       consigneVitesseMoteurGauche_rad_s = vitesseConsigneCG_rad_par_s+deltaV;
00371       consigneVitesseMoteurDroit_rad_s = vitesseConsigneCG_rad_par_s-deltaV;
00372     }
00373     <span class="keywordflow">else</span>
00374     {
00375       ecartAngulaire_rad *=-1;
00376       deltaV = vitesseConsigneCG_rad_par_s*(gainCorrectionAngulaire*ecartAngulaire_rad -1)/(gainCorrectionAngulaire*ecartAngulaire_rad + 1);
00377       consigneVitesseMoteurDroit_rad_s = vitesseConsigneCG_rad_par_s+deltaV;
00378       consigneVitesseMoteurGauche_rad_s = vitesseConsigneCG_rad_par_s-deltaV;
00379     }
00380     log &lt;&lt;  positionAttVit-&gt;attitude_rad&lt;&lt;<span class="stringliteral">"\t"</span>&lt;&lt;capCercleIdeal &lt;&lt;<span class="stringliteral">"\t"</span>&lt;&lt; ecartAngulaire_rad &lt;&lt;<span class="stringliteral">"\t"</span>
00381         &lt;&lt; consigneVitesseMoteurDroit_rad_s&lt;&lt;<span class="stringliteral">"\t"</span>&lt;&lt; consigneVitesseMoteurGauche_rad_s&lt;&lt;<span class="stringliteral">"\t"</span>&lt;&lt;vitesseConsigneCG_rad_par_s&lt;&lt;<span class="stringliteral">"\t"</span>
00382         &lt;&lt; distanceCurviligneJusqueWP &lt;&lt;<span class="stringliteral">"\t"</span>&lt;&lt; distanceDeceleration &lt;&lt;endl;
00383     <span class="keyword">delete</span> centreDuCercle;
00384   }
00385   <span class="keywordflow">else</span>
00386   {
00387     <span class="comment">//plus de WP, il faut arreter le robot</span>
00388     consigneVitesseMoteurDroit_rad_s = 0;
00389     consigneVitesseMoteurGauche_rad_s = 0;
00390     log &lt;&lt;endl;
00391   }
00392   
00393 }
00394 <span class="keywordtype">void</span> AlgoPIC::miseAjourWaypoint(vectorWayPoint listeWP)
00395 {
00396   WayPoint * wpEnCours;
00397   <span class="keywordflow">if</span> (numeroWPenCours &lt; listeWP.size())
00398   {
00399     wpEnCours = listeWP[numeroWPenCours];
00400     <span class="keywordtype">double</span> distanceRobot_WPenCours = positionAttVit-&gt;pt-&gt;distanceAuPoint(wpEnCours-&gt;pt);
00401     <span class="keywordflow">if</span> (distanceRobot_WPenCours &lt; 0.01)
00402     {
00403         numeroWPenCours++;
00404     }
00405     log &lt;&lt; numeroWPenCours &lt;&lt;<span class="stringliteral">"\t"</span>&lt;&lt; distanceRobot_WPenCours &lt;&lt;<span class="stringliteral">"\t"</span>;
00406   }
00407 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Thu Apr 27 10:54:52 2006 for SIMULATEUR by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
